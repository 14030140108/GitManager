# 内部类

## 序言

1. 可以将一个类的定义放在另一个类的内部，叫做内部类，或者嵌套类(静态内部类)

## 1.1 创建内部类
1.静态内部类

    - 静态类只可能出现在内部类，外部类如果用static修饰编译都不通过

2. 静态内部类和非静态内部类的区别
    - 非静态内部类中不能声明static成员变量和方法，静态内部类中可以
    - 静态内部类可以单独初始化，普通内部类需要借助外部类
    ```
        //静态内部类初始化
        Inner inner = new Outer.Inner();
        //普通内部类初始化
        Outer outer = new Outer()
        Inner inner = outer.new Inner();
    ```
    - 非静态内部类可以访问外围类的所有成员变量(包括private修饰的)，静态内部类则只能访问外部类的静态成员变量和方法
3. 普通内部类对象必须依附于外部类对象

## 1.2 链接外部类
1. 内部类自动拥有对其外围类所有成员的访问权
2. 当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密的捕获一个指向那个外围类对象的引用，然后在你访问外围类的成员时，就是用那个引用来选择外围类的成员。

## 1.3 使用.this和.new
1. 在内部类中生成外部类的引用使用OuterClassName.this
2. 当外部类想要创建某个内部类的对象时，使用.new表达式

## 1.4 内部类与向上转型

1. 当内部类为private时，只有外部类才有访问它的权限
2. 当内部类为protected时，只有外部类、外部类的子类及外部类所在同一级包下的所有类有访问权限
    - 当一个类或者方法被用protected修饰时，具有访问权限的类为
        1. 该类所在的外部类或者该方法所在的类
        2. 外部类的子类或者方法所在类的子类
        3. 同一级包下的其他类
    - 当一个类没有写构造函数时，编译器默认增加一个无参构造函数，访问级别和类的级别一致
3. 在外部客户端程序员的角度来看，由于不能访问任何新增加的，原本不属于公共接口的方法，所以扩展接口是没有价值的。

4. 一个类的定义只可能在三个地方
    - 一个文件中
        - 该类一般为public类，类名和文件名相同
    - 和另一个类在同一个文件中
        - 在同一个文件中的类最多只能有一个public类(可以没有),如果有，则文件名与public类的类名相同，如果没有则与其中一个类的名字相同即可（其他的类的修饰符abstract/final/没有修饰符）
        - public类其他文件可以访问，其他的类只能在文件内部互相访问，不能被其他文件中的类访问
    - 在一个类的内部
        - 该类的修饰级别可以任意

## 1.5 在方法和作用域内的内部类
1. 内部类的定义可以在方法中，也可以在方法的作用域中

## 1.6 匿名内部类
1. 匿名内部类的语法指的是
    - 创建一个继承自contenets匿名类的对象
    - 通过new表达式返回的引用被自动向上转型为对Contents的引用
    - 在匿名内部类中使用的参数必须用final修饰
    - 在匿名类中不可能有命名构造器，因为它根本就没有名字
    - 可以通过实例初始化，达到为匿名内部类创建一个构造器的效果
    - 匿名类既可以扩展类，也可以实现接口，但是两者不能兼备，并且如果实现接口，只能实现一个接口

## 1.7 嵌套类

1. 嵌套类就是静态内部类

### 1.7.1 接口内部的类
1. 接口内部的任何类都自动地是public和static的，所以接口中的类都是嵌套类(静态内部类)
2. 接口内部的方法都是public的
3. 接口内部的嵌套类甚至可以直接实现外部的接口
4. 当你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便

### 1.7.2 从多层嵌套类中访问外部类的成员
1. 多层内部类的嵌套，它能透明的访问所有它所嵌入的外围类的所有成员

## 1.8 为什么需要内部类
1. 内部类允许继承多个非接口类型(类或者抽象类)
2. 如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承

### 1.8.1 闭包与回调

### 1.8.2 内部类与控制框架
1. 应用程序框架
    - 被设计用以解决某类特定问题的一个类或一组类
2. 事件驱动系统
    - 主要用来响应事件的系统被称作事件驱动系统
3. 控制框架
    - 一类特殊的应用程序框架

## 1.9 内部类的继承
1. 内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的引用必须被初始化，而在导出类中不再存在可连接的默认对象
    	- 第一句话的意思是实例化内部类的时候，必须用一个外部类对象的引用去调用内部类的构造函数
2. 一个类继承某个类的内部类，在构造器中需要传递一个指向外围类对象的引用，并调用外围类对象的构造函数
    	- enclosingClassReference.super()   （特殊语法）
        	- 上面的super实质上是调用内部类的构造函数

## 1.10 内部类可以被覆盖吗

1. 在一个类A中定义一个内部类InnerA，在另一个类B中继承A，也定义一个内部类InnerA

    - 类A和类B中的两个内部类是完全独立的个体，处在不同的命名空间中

        - 类B中的内部类不会覆盖类A中的内部类

    - 当类A和类B中覆盖函数时，如下代码，父类中的函数会被子类覆盖

        ```java
        // Egg.java
        public class Egg {
            public Egg() {
                System.out.println("this is Egg");
                sayHello();
            }
            public void sayHello() {
                System.out.println("Egg say Hello World!");
            }
        }
        
        // BigEgg.java
        public class BigEgg extends Egg {
            public void sayHello() {
                System.out.println("BigEgg say Hello World!");
            }
            public static void main(String[] args) {
                new BigEgg();
            }
        }
        
        //output:
        this is Egg
        BigEgg say Hello World!
        ```

2. 所以当内部类没有被继承时，不会被覆盖，当被继承时，其中可以覆盖内部类指定的方法

## 1.11 局部内部类

1. 局部内部类和匿名内部类
    - 局部内部类的名字在方法外是不可见的，不能用访问控制符和static修饰
    - 局部内部类可以有命名构造器，匿名内部类没有，只能用实例初始化(非静态代码块)
    - 所以使用局部内部类而不使用匿名内部类的理由是：需要不止一个该内部类的对象1.1

## 1.12 内部类标识符

1.  每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息
2. 内部类文件的命名规则为:外围类的名字，加上 “$”,在加上内部类的名字
3. 如果内部类是匿名的，编译器会简单的产生一个数字作为其标识符