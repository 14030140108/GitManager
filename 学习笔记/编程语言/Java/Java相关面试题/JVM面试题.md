# 一、JVM面试题

## 1.1JVM运行时数据区

- 线程私有：程序计数器、Java虚拟机栈(栈帧(局部变量表，操作数栈，方法出口))，本地方法栈
- 线程共享：堆(新生代和老年代)和元空间，其中新生代分为Eden、From、To，元空间使用的本地内存
	- JDK1.7及之前，有方法区(使用JVM内存，也叫永久代)里面存储类的元数据信息、静态变量和常量，JDK1.8中将方法区取消，增加了元空间用来存储类的元数据信息，静态变量和常量存放在堆中

## 1.2 为什么JDK1.8中要移除永久代

- 字符串存在永久代中，容易出现性能问题和内存溢出
- 永久代会为GC带来不必要的复杂度，并且回收效率偏低

## 1.3 Class对象可以被回收的条件

- 该类的所有实例对象均被回收
- 该类的类加载器被回收
- 该类的class对象没有被引用，该类不能通过反射访问到其方法

## 1.4 JVM性能调优参数

- -Xms：初始化堆的大小
- -Xmx：堆的最大值大小
- -Xss：初始化线程虚拟机栈的大小
- -Xmn：年轻代的大小
- -XX:MaxMetaSpaceSize：该参数可以限制元空间的大小

## 1.5 程序计数器的作用

- Java字节码解释器工作时就是通过更改程序计数器的值来选取下一条需要执行的字节码指令
- Java多线程是通过线程轮流切换并分配处理器的执行时间来实现的，线程的恢复就靠的是每个线程的程序计数器

## 1.6 堆和栈的区别

- 栈是线程私有的，堆是线程共享的
- 栈空间在用完之后自动释放，堆需要进行GC
- 栈的效率比堆高

## 1.7 是不是所有的对象和数组都会在堆内分配空间？

- 不一定，如果JIT(即时编译器)经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化为栈内存分配

## 1.8 不同的JDK版本intern方法有什么区别？

- JDK1.6中字符串常量池在方法区，当调用intern时，如果字符串常量池中没有该字符，则会添加该字符并返回字符串引用

- JDK1.7中，字符串常量池在堆中，当调用intern时，如果字符串常量池中没有该字符，那么会添加字符串对象的引用到字符串常量池中，

	```java
	String s = new String("1") + new String("1");
	s.intern();
	String s1 = "11";
	System.out.println(s == s1)
	//output:
	    JDK 1.6:false
		JDK 1.7:true
	```

## 1.9 Java对象的创建过程

1. 判断其对应的类对象释放已经被加载和初始化
2. 为对象分配内存空间(空闲列表)
3. 将分配的内存空间初始化为零值
4. 设置对象的对象头
5. 对对象的成员变量进行初始化，并执行构造函数

## 1.10 Java对象的生命周期

1. 创建阶段
2. 应用阶段：至少有一个强引用
3. 不可达阶段：不在被任何强引用持有
4. 收集阶段：执行对象的finalize()方法
5. 终结阶段：在该阶段等待垃圾回收器回收
6. 对象重新分配阶段：垃圾回收器对该对象所占用的内存空间进行回收和在分配

## 1.11 Java对象的定位

- 句柄：堆中将会划分出一块内存来作为句柄池，里面保存了对象的实际数据的地址和存储类元数据的地址，引用变量所引用的就是句柄的值，当对象移动的时候不需要修改引用变量的值
- 直接指针：引用变量直接指向对象的实际数据地址，节省了一次指针定位的开销，但是当对象移动的时候需要修改引用变量的值(HotSpot采用的就是这个)

## 1.12 判断一个对象是否可以被回收

- 引用计数：给对象加一个引用计数器，很难解决循环引用的问题
- 可达性分析：从GC Roots作为起始点向下搜索，当一个对象到GC Roots没有任何的引用链时，证明此对象是不可用的，可以回收
	- 具体其实会有两次标记的过程，第一次标记结束后，判断该对象有没有重写finalize方法，如果重写了会将该对象放入一个队列中，去执行对象的finalize方法，当执行结束后再一次去标记如果还是可回收状态则该对象真的要被回收了，在finalize中可以实现对象的自救，且只能执行一次，并且不保证会执行完

## 1.13 GC Roots的对象引用

- 局部变量引用的对象
- 静态变量引用的对象
- 常量引用的对象
- 本地方法栈中JNI引用的对象

## 1.14 GC Roots和OopMap以及安全点

- GC Roots不可能每次都去所有的栈和方法区去找这些对象，HotSpot有一个oopMap数据结构，通过oopMap可以知道哪些地方存放着GC Roots的对象引用，当程序运行到安全点时，更新一下oopMap
- 安全点一般是循环的末尾，方法返回前，可能抛出异常的地方

## 1.15 垃圾回收算法

- 标记-清除
	- 容易出现大量的内存碎片，导致分配较大对象时提前触发GC
- 标记-整理
	- 老年代Full GC
- 复制
	- Minor GC
- 分代收集

## 1.16 类加载的过程

- 加载-验证-准备-解析-初始化，其中验证-准备-解析统称为连接阶段
	- 加载：通过一个类的全限定名获取此类定义的二进制流，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个代表该类的的Class对象
	- 验证：验证Class对象中的字节流包含的信息是否符合虚拟机的要求
	- 准备：正式为静态变量分配内存并设置类变量的初始值，该值为0或者null
	- 解析：将常量池的符号引用替换为直接引用的过程
	- 初始化：执行类的Clinit方法(由用户需要初始化的静态变量语句组织起来的)，确保父类的clinit先执行，并且在多线程下会进行加锁和同步

## 1.17 类初始化的情况

- new的时候
- 调用静态变量或者静态函数的时候
- 反射调用的时候
- 当初始化类的时候，如果父类还没有初始化，则先初始化父类

## 1.18 不会触发初始化

- 当子类直接调用父类的静态字段时，不会触发子类的初始化，但是会触发父类的初始化
- 当定义数组的引用时，不会触发初始化
- 调用类的常量不会触发初始化，常量在编译期间就别存放在方法区了

## 1.19 类加载器

- BootStrapClassLoader：根类加载器，负责JAVA_HOME/lib目录下的类
- ExtensionClassLoader：扩展类加载器，负责JAVA_HOME/lib/ext下的类
- ApplicationClassLoader：系统类加载器，负责加载ClassPath中的类
- 自定义类加载时通过继承ApplicationClassLoader，重写里面的findClass方法或者重写loadclass方法
- JDK-SPI打破了双亲委派模型：因为ServiceLoader中使用Thread.currentThread.getContextClassLoader()获取系统类加载器，加载META-INF/Services下的实现类

## 1.20 垃圾收集器

- Parallel Scavenge
	- 是一个新生代的收集器，采用复制算法
	- 不能与CMS同时工作
	- 目标是提升cpu的吞吐量
- Parallel Old
	- JDK1.6开始提供，只能和Parallel Scavenge配合使用
	- 老年代回收采用标记-整理算法
- CMS
	- 初始标记阶段
	- 并发标记阶段
	- 重新标记阶段
	- 回收阶段
- G1
	- G1收集器可以新生代和老年代一起回收
	- G1把堆划分成多个大小相等的独立区域，引入了region的概念，从而将原来一整块内存空间划分成多个小空间，使得每个小空间可以单独进行回收，使得可预测的停顿时间成为可能。

## 1.21 OOM问题

- Java堆溢出：不断的创建对象，当对象的数量到达堆的容量限制后就会产生内存溢出OOM
- 栈溢出：当给一个线程分配Java虚拟机栈时，如果没有足够的空间则抛出OOM
	- 当线程的Java虚拟机栈中的存储的容量大于Java虚拟机栈的大小时，抛出StackOverflowError
- 元空间溢出
- 本地内存溢出：使用Unsafe.allocateMemory不断分配堆外内存
- 排查OOM的工具
	- jmap：OOM问题和内存不足 ，生成内存快照，-heap可以查看堆的配置情况
	- jstat：gc的情况可以使用该命令
	- jstack：线程死锁，线程卡死

