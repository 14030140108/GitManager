# 一、HTTPS详解

- 用A公钥加密的数据，只能用A私钥解密，同理用A私钥加密的数据，也只能用A公钥解密
- 信息摘要就是将数据经过hash函数运算得出的一个字符串，无法恢复
- 签名就是CA中心用自己的私钥加密信息摘要(数据是来源者的一些基本信息)，
- 证书就是经过签名后颁发的一个证书，证书里还有签名的信息

## 1.1 HTTPS协议访问流程

- 客户端和服务器之间通过非对称密钥获取随机密钥，然后使用对称加密算法传输数据
	- 客户端有自己的私钥和公钥，服务器有自己的私钥和公钥，客户端和服务器之间互相交换自己的公钥
	- 首先将随机密钥用对方的公钥加密然后发送给对方，对方用自己的私钥解密
- 协议访问步骤
	- 首先客户端通过HTTPS协议请求访问某个服务器，该服务器会通过443端口将CA机构颁发的证书返回给客户端
	- 客户端拿到该证书后，使用该CA机构的公钥进行解密，如果成功，则表明该服务器的公钥确实经过了CA的认证
	- 客户端还会验证该证书中的签名信息有没有被修改，将内容通过hash计算后得到的值与解密签名后得到的信息摘要进行比对，如果相同表示该证书信息未被修改
	- 客户端拿到服务器的公钥，之后对随机密钥用服务器公钥进行加密，发送给服务器，服务器用私钥解密后获得随机密钥
	- 客户端和服务器接下来使用对称加密算法传输数据，密钥就是双方都知道的随机密钥

## 1.2 自己的理解

- 信息摘要就是把真实的数据经过hash计算后得出的字符串，不可恢复

- 签名就是把信息摘要用私钥进行加密

- 证书就是CA机构经过上述的步骤后颁发的一个文件，里面包含有签名和信息摘要的真实数据

- SSL(Secure Socket Layer)

	- SSL握手协议：用于在实际数据传输之前，进行身份认证、协商加密算法、交换加密密钥等
	- SSL记录协议：提供传输数据的压缩、加密等功能

	

# 二、HTTP

## 2.1 HTTP2.0和HTTP1.1的不同

- HTTP1.1需要使用多个TCP连接来达到并发的效果，HTTP2.0只会有一个TCP连接，可以承载任意数量的双向数据流
- HTTP2.0会进行首部压缩
- HTTP2.0在客户端请求一个资源时，会把相关的资源一起发送给客户端
- HTTP2.0使用二进制分帧
	- 每个请求切成Stream，用Stream ID标识
	- Header Frame和Data Frame

## 2.2 HTTP1.1和HTTP1.0

- HTTP1.0每次请求都需要建立TCP连接，浪费大量的时间。HTTP1.1之后使用Connect：keep-alive可以默认设置长连接，建立TCP连接之后，传输完数据不断开，之后可以继续发送数据

## 2.3 请求报文

- 请求行  ： 方法   URL字段  http协议版本
- 请求头部   ：指明的请求类型(host、Accept-Charset、Accept-Encoding)
- 空行
- 请求数据

## 2.4 响应报文

- 响应行：Http协议版本   状态码  描述
- 响应头 ： 数据的描述信息(Allow、Content-Encoding、Content-length、Content-Type)
- 响应体

## 2.5 HTTP方法

- GET   ：请求指定的页面信息
- POST：向指定资源提交数据，数据包含在请求体中
- HEAD：类似get请求，只不过返回的响应中没有响应内容，用于获取响应的头部
- HTTP1.1新增
	- OPTIONS：查询指定的url支持的方法
	- PUT
	- DELETE
	- PATCH：put可以用来修改资源，不过只能是全部替换，patch可以实现资源的部分修改
	- TRACE：可以将服务器的通信路径返回给客户端
	- CONNECT：让服务器代替客户端去访问一些页面并返回。
- GET和POST的区别
	- GET一般用于请求指定的页面信息，POST一般用于向服务器提交数据
	- get只支持ASCII字符的数据，post支持任意类型的数据
	- get有长度限制(URL的长度限制2048字节)，post没有长度限制

## 2.6 HTTP状态码

- 1XX：表示服务器收到请求，客户端可以继续发送响应
- 2XX：成功
- 3XX：重定向
- 4XX：客户端错误
- 5XX：服务器错误

## 2.7 短链接和长连接

- HTTP1.1开始默认长连接，Connection：keep-Alive
- 关闭长连接，Connection：close

##  2.8 Cookie

- HTTP协议是无状态的，HTTP1.1引入了Cookie来保存状态信息

- Cookie是服务器发送到用户浏览器并保存在本地的一小块数据。

- 它会在浏览器下次访问同一个服务器的请求时被携带上(Cookie字段)，服务器根据这个cookie就知道这个请求是来自哪个客户端

- Cookie在响应头中的set-cookies，包含cookie的名字，值，过期时间、域名、路径

- Cookie匹配的规则：域名必须一致、cookie必须有效、路径必须在指定的路径之内(只有匹配成功该次请求才会带上该Cookie)

- 分类

	- 会话期Cookie：指在当前会话期间有效
	- 持久性Cookie：指定过期时间或者有效时间之后就会成为持久性Cookie

- Session

	- 除了可以将用户信息通过cookie存储在用户浏览器中，也可以利用Session存储在服务器端，更加安全。
	- 服务器产生一个sessionID通过Cookie传给客户端，客户端将其存入浏览器缓存中

- Session和Cookie

	- Cookie只能存储ASCII码字符串，Session可以存储任意类型数据
	- Cookie存储在浏览器中，容易被恶意查看，可以加密存储
	- 对于大型网站，如果用户信息都存在Session中，服务器的开销将会很大

## 2.9 范围请求

- 在请求报文中添加Range字段和请求的范围，服务器请求成功的话返回206状态码。
- Accept-Ranges：响应首部字段用于告知客户端是否能处理范围请求
- 响应状态码
	- 请求成功：206
	- 请求范围越界：416
	- 不支持范围请求：200

## 2.10 通信数据转发

- 代理
	- 缓存
	- 负载均衡
	- 网络访问控制
	- 访问日志记录
- 网关
- 隧道

## 2.11 优缺点

- 优点
	- 简单，灵活使用
	- 应用广泛，跨语言，跨平台
	- 无状态，不需要额外的资源来保存状态信息，能减轻服务器的负担
	- 明文：方便开发调试
- 缺点
	- 无法支持需要连续多个步骤的事务操作，增加了数据传输量
	- 明文，不安全

# 三、URL和URI

- URI是统一资源标识符，它是无法定位到资源的，只是用来唯一标识一个资源的
- URL是统一资源定位符，我们通常在浏览器看到的协议+域名+端口+路径组成了一个URL
- URN和URL是URI的子集

